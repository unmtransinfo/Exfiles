##############################################################################
### Modes:
###      VIEW: geneA
### SIMSEARCH: via profile similarity
### TXTSEARCH: via symbols or names
###   COMPARE: geneA vs. geneB
### SABV: sex-as-biological-variable analysis
##############################################################################
### GGC = gene-gene associations
### EPS = Expression Profiles
##############################################################################
### exfiles.Rdata generated by exfiles_final_files.R
##############################################################################
### Requires shinysky, devtools::install_github("AnalytixWare/ShinySky")
##############################################################################
library(readr)
library(wCorr)
library(shiny, quietly=T)
library(shinyBS, quietly=T)
library(shinysky) #textInput.typeahead
library(DT, quietly=T)
library(data.table, quietly=T)
library(plotly, quietly=T)
#
pkgs <- names(sessionInfo()$otherPkgs)
pkgVerTxt <- paste(sprintf("%s %s", pkgs, sapply(pkgs, function(p){paste(packageVersion(p), collapse=".")})), collapse="; ")
message(pkgVerTxt)
###
# This code runs once for all sessions.
###
APPNAME <- "Exfiles"
APPNAME_FULL <- "Exfiles: Expression profile analytics SABV"
GTEX_RELEASE <- "v8 (2017)"
#
IGNORE_SEX_SPECIFIC_TISSUES <- T
###
t0 <- proc.time()
if (!file.exists("exfiles.Rdata")) {
  message(sprintf("ERROR: exfiles.Rdata NOT FOUND."))
} else {
  message(sprintf("Loading exfiles.Rdata..."))
  load("exfiles.Rdata")
}
#
message(sprintf("Gene count (ENSG): %d", uniqueN(gene$ENSG)))
message(sprintf("Gene count (SYMB): %d", uniqueN(gene$symbol)))
message(sprintf("Gene count (UniProt): %d", uniqueN(gene$uniprot)))
message(sprintf("Tissue count (profiles): %d", ncol(eps)-2))
message(sprintf("Tissue count (shown): %d", uniqueN(tissue$SMTSD)))
message(sprintf("Gene-gene signature comparisons: %d", nrow(ggc)))
#
hiddenTissues <- setdiff(names(eps)[3:ncol(eps)], tissue$SMTSD)
for (tis in hiddenTissues) {
  message(sprintf("Tissue hidden (SMTSD): %s", tis))
}
if (IGNORE_SEX_SPECIFIC_TISSUES) {
  tissue <- tissue[(!SEX_SPECIFIC)]
  tissue <- tissue[SMTSD != "Kidney - Medulla"] #No female TPMs in GTEx. Why?
}
tissue <- tissue[SMTSD %in% colnames(eps)]
TAGS_THIS <- c("ENSG", "SEX", tissue$SMTSD)
eps <- eps[, ..TAGS_THIS]
#
###
ggc[, Combo := round(wRho*Ruzicka, digits=2)]
#
db_htm <- sprintf("<B>Dataset:</B> Genes: %d ; tissues: %d ; comparisons: %d", uniqueN(gene$ENSG), uniqueN(tissue$SMTSD), nrow(ggc))
message(sprintf("t_load: %.1fs", (proc.time()-t0)[3]))
message(sprintf("IGNORE_SEX_SPECIFIC_TISSUES: %s", IGNORE_SEX_SPECIFIC_TISSUES))
###
#
#############################################################################
#
### Unweight smaller, noise-dominated expression values.
wPearson <- function(A,B) {
  ok <- !is.na(A) & !is.na(B)
  A <- A[ok]
  B <- B[ok]
  wCorr::weightedCorr(A, B, method="Pearson", weights=(A+B)/2)
}
###
Ruzicka <- function(A,B) {
  sum(pmin(A,B), rm.na=T)/sum(pmax(A,B), rm.na=T)
}
###
EpLogIf <- function(ep, condition) {
  if (condition) { return(log10(ep+1)) }
  else { return(ep) }
}
###
# Create menu input autocomplete.
gene_menu <- gene
gene_menu[, symbol := ifelse(!is.na(symbol), symbol, ENSG)] #NAs break autocomplete.
#
OrderGeneSymbols <- function(symbols) {
  genes <- data.table(symbol=symbols, prefix=NA, i=NA)
  genes[, are_prefixed := grepl("^[A-Z]+[0-9]+$", symbol)]
  genes[(!are_prefixed), prefix := as.character(symbol)]
  genes[(are_prefixed), prefix := sub("[0-9]+$", "", symbol)]
  genes[(are_prefixed), i := as.integer(sub("^[A-Z]+", "", symbol))]
  return(order(genes$prefix, genes$i, na.last=T))
}
#############################################################################
HelpHtm <- function() {
  htm <- sprintf(
"<P><B>%s</B> allows exploration and analysis of co-expression patterns via gene expression profiles,
from <B>GTEx</B> RNA-seq data, with <B>Sex As a Biological Variable (SABV)</B>.
Gene expression profiles are computed as real valued vectors of expression levels 
across the defined tissue types.
<B>Expression data source:</B> <a href=\"https://gtexportal.org\">GTEx</a> [%s] RNA-Seq download file, 
plus samples and subjects metadata/annotations.
<P>
<B>Inputs</B> are query GeneA, and <I>optionally</I>, GeneB.
Ex-files modes of operation:
<UL>
<LI><B>VIEW</B> - view profile for one gene
<LI><B>COMPARE</B> - compare input genes via profiles
<LI><B>SIMSEARCH</B> - search for genes based on profile similarity
<LI><B>TXTSEARCH</B> - search for genes based on symbols or names
</UL>
<P>
<B>Score:</B>
<UL>
<LI><B>Ruzicka</B> - Similarity measure, size-normalizing, hence advantageous over Euclidean, RMSD, etc.
<LI><B>wRho</B> - Weighted Pearson correlation coefficient, weighted by average values for each tissue, to mitigate noise.
<LI><B>Combo</B> - Product wRho*Ruzicka, scoring function balancing correlation and similarity.
</UL>
<B>Results:</B>
<UL>
<LI><B>VIEW:</B> plots query GeneA with sex-specific profiles.
<LI><B>COMPARE:</B> plots query GeneA vs. GeneB with sex-specific profiles.
<LI><B>SIMSEARCH:</B> returns hits based on the GeneA query. The top hit is displayed against GeneA in the plot, and other hits displayed in a table, plotted by manual selection, and downloadable as TSV.
<LI><B>TXTSEARCH:</B> returns hits based on the query, which may be a substring, regular expression, or space-separated list of exact symbols. Hits are displayed in the table, plotted by manual selection, and downloadable as TSV.
<LI><B>Groups</B> denote comparisons among F-only, M-only or C (Combined-sex) representing un-stratified subjects, computed as mean of F and M profiles.
<LI>Expression units: <B>TPM</B> = RNA-seq Transcripts Per Million-kilobase or <B>LOG<SUB>10</SUB>(1+TPM)</B>.
<LI>Expression profiles are computed as medians for GTEx samples, by tissue and sex.
<LI>Option Dissim[ilarity] reverse-sorts search results. To find anti-correlated genes, search by wRho.
<LI><B>Sex-linked genes</B> may be identified via chromosomal location (X*/Y*).
<LI><B>IDG (Illuminating the Druggable Genome)</B> provides target development level (TDL), Drug Target Ontology (DTO) classification,
and links to IDG data portal Pharos.
</UL></P>
<P>
HTTP GET parameters supported:
<UL>
<LI> geneA - ENSG for gene A, for VIEW, COMPARE and SIMSEARCH.
<LI> geneB - ENSG for gene B, for COMPARE.
<LI> queryTxt - text query for TXTSEARCH.
<LI> mode - VIEW, COMPARE, SIMSEARCH, TXTSEARCH
</UL>
Examples:
<blockquote>
<PRE>
/?geneA=ENSG00000070214&mode=VIEW
/?geneA=ENSG00000070214&geneB=ENSG00000137968&mode=COMPARE
</PRE>
</blockquote>

<p>
<B>Notes on data preparation:</B> This version is focused on SABV knowledge discovery, thus reproductive and 
breast tissues not included in profile comparison computations. Also limited to protein-encoding genes unambiguously 
mapped to HUGO gene symbols. Search results where ruz&lt;0.50 and |wRho|&lt;0.50 are excluded from dataset.
Note that tissue \"Kidney - Medulla\" is not biologically but artifactually sex-specific since in GTEx there are no
female TPM data.
</P>
<B>Reference:</B>\"Exfiles: Sex-Specific Gene Expression Profiles Analytics\", Bocci et al., <i>[in preparation]</i>.<BR/>
<B>Authors:</B> Giovanni Bocci, Oleg Ursu, Cristian Bologa, Steve Mathias, Jeremy Yang &amp; Tudor Oprea, <A HREF=\"http://datascience.unm.edu\" target=\"_blank\">Translational Informatics Division, University of New Mexico</A><BR/>
<B>Correspondence</B> from users of this app is welcome, and should be directed to <a href=\"mailto:jjyang_REPLACE_WITH_ATSIGN_salud.unm.edu\">Jeremy Yang</a>.<br/>
Data from <A HREF=\"https://www.gtexportal.org/\" TARGET=\"_blank\">GTEx, The Genotype-Tissue Expression Project</A>.<BR/>
This work was supported by the National Institutes of Health grants OT3-OD025464 and U24-CA224370.<BR/>
", APPNAME_FULL, GTEX_RELEASE)
  htm <- paste(htm, sprintf("<hr>\nPowered by: <tt>%s; %s</tt>", R.version.string, pkgVerTxt), sep="\n")
  return(htm)
  }
#
#############################################################################
ui <- fluidPage(
  titlePanel(
    tags$table(width="100%", tags$tr(tags$td(
    h2("IDG", tags$img(height="50", valign="bottom", src="IDG_logo_only.png"), APPNAME_FULL, span(icon("venus", lib="font-awesome"), icon("mars", lib="font-awesome")))),
    tags$td(align="right",
      actionButton("goReset", "Reset", style="padding:4px; background-color:#DDDDDD;font-weight:bold"),
      actionButton("showhelp", "Help", style="padding:4px; background-color:#DDDDDD;font-weight:bold")))),
    windowTitle=APPNAME_FULL),
  fluidRow(
    column(5, 
        wellPanel(
    radioButtons("mode", "Mode", choices=c("VIEW", "COMPARE", "SIMSEARCH", "TXTSEARCH"), selected="VIEW", inline=T),
	conditionalPanel(condition="input.mode == 'TXTSEARCH'",
	      textInput("qryTxt", "Query (list or regex)", width='80%'),
	      checkboxInput("iCase", "IgnoreCase", value=T, width='20%')),
	conditionalPanel(condition="input.mode != 'TXTSEARCH'",
        shinysky::textInput.typeahead(id="qryA", placeholder="GeneA...",
		local=gene, valueKey="ENSG", tokens=gene$symbol,
		template=HTML("<p class='repo-name'>{{symbol}}({{ENSG}})</p> <p class='repo-description'>{{name}}</p>"), limit=10)
        ),
	conditionalPanel(condition="input.mode == 'COMPARE'",
        shinysky::textInput.typeahead(id="qryB", placeholder="GeneB...",
		local=gene, valueKey="ENSG", tokens=gene$symbol,
		template=HTML("<p class='repo-name'>{{symbol}}({{ENSG}})</p> <p class='repo-description'>{{name}}</p>"), limit=10)
	),
	  conditionalPanel(condition="input.mode == 'SIMSEARCH'",
            radioButtons("score", "Score", choices=c("Ruzicka", "wRho", "Combo"), selected="Combo", inline=T)),
	  conditionalPanel(condition="input.mode == 'TXTSEARCH'",
            radioButtons("field", "Field", choices=c("Symbol", "Name"), selected="Symbol", inline=T)),
          checkboxGroupInput("groups", "Groups", choiceValues=c("F", "M", "C"), choiceNames=c("F", "M", "Combined"), selected=c("F", "M"), inline=T),
          checkboxGroupInput("opts", "Output", choices=c("IDG", "Dissim", "LogY", "Annplot"), selected=c("IDG", "LogY", "Annplot"), inline=T)),
	wellPanel(htmlOutput(outputId = "log_htm", height = "120px")),
        wellPanel(htmlOutput(outputId = "result_htm", height = "120px")),
	wellPanel(actionButton("goSubmit", label="Submit", icon=icon("cogs"), style='background-color:#EEEEEE;border-width:2px'))
	),
    column(7, conditionalPanel(condition="true", plotlyOutput("plot", height = "580px")))
  ),
  conditionalPanel(condition="output.hits_exist=='TRUE'",
    wellPanel(fluidRow(column(12, DT::dataTableOutput("datarows"))),
              fluidRow(column(12, downloadButton("hits_file", label="Download"))))),
  fluidRow(
    column(12, em(strong(sprintf("%s", APPNAME)), " web app from ", 
	tags$a(href="https://datascience.unm.edu", target="_blank", span("UNM", tags$img(id="unm_logo", height="60", valign="bottom", src="unm_new.png"))),
	" and ",
	tags$a(href="https://druggablegenome.net", target="_blank", span("IDG", tags$img(id="idg_logo", height="60", valign="bottom", src="IDG_logo_only.png"))),
	" built from ",
	tags$a(href="https://gtexportal.org", target="_blank", span("GTEx", tags$img(id="gtex_logo", height="50", valign="bottom", src="GTEx_logo_only.png")))
	))),
  bsTooltip("qryA", "Needed for all modes.", "top"),
  bsTooltip("qryB", "Needed for COMPARE mode only", "top"),
  bsTooltip("qryTxt", "Enter space-separated list of gene symbols, or regular expression.", "top"),
  bsTooltip("mode", "VIEW 1 gene, COMPARE 2 genes, or Search for similar genes.", "top"),
  bsTooltip("score", "Ruzicka similarity, Pearson weighted correlation, or combination of both.", "top"),
  bsTooltip("groups", "Search F-only, M-only, or Non-sexed comparisons.", "top"),
  bsTooltip("opts", "Output options affecting plot and datatable but not query logic.", "top"),
  bsTooltip("unm_logo", "UNM Translational Informatics Division", "right"),
  bsTooltip("idg_logo", "IDG, Illuminating the Druggable Genome project", "right"),
  bsTooltip("gtex_logo", "GTEx, Genotype-Tissue Expression project", "right"),
  conditionalPanel(condition="true", span(style="color:white", textOutput("hits_exist"))) #fails_if_hidden
)

#############################################################################
server <- function(input, output, session) {
  
  observeEvent(input$showhelp, {
    showModal(modalDialog(easyClose=T, footer=tagList(modalButton("Dismiss")),
      title=HTML(sprintf("<H2>%s Help</H2>", APPNAME)),
      HTML(HelpHtm())
    ))
  })
  
  Sys.sleep(1) #Needed?
  i_query <- 0 # initialize once per session

  urlBase <- reactive({
    sprintf("%s//%s:%s%s",
      session$clientData$url_protocol, session$clientData$url_hostname,
      session$clientData$url_port, session$clientData$url_pathname)
  })
  urlText <- reactive({
    sprintf("%s%s", urlBase(), session$clientData$url_search)
  })

  httpQstr <- reactive({
    message(sprintf("DEBUG: url: \"%s\"", urlText()))
    qStr <- getQueryString(session) #named list
    if (length(qStr)>0)
      for (key in names(qStr))
        message(sprintf("DEBUG: qStr[[\"%s\"]]=\"%s\"", key, qStr[[key]]))
    return(qStr)
  })

  observe({
    message(sprintf("NOTE: mode: %s", qryVals()$mode))
    if (qryVals()$mode=="SIMSEARCH") { message(sprintf("NOTE: score: %s", input$score)) }
    if (!is.na(qryVals()$geneA)) { message(sprintf("NOTE: qryA = %s (%s: \"%s\")", qryVals()$geneA, symbA(), gene[symbol==qryVals()$geneA, name])) }
    if (!is.na(qryVals()$geneB)) { message(sprintf("NOTE: qryB = %s (%s: \"%s\")", qryVals()$geneB, symbB(), gene[symbol==qryVals()$geneB, name])) }
  })

  observeEvent(input$goReset, {
    shiny::updateTextInput(session, "geneA", value="")
    shiny::updateTextInput(session, "geneB", value="")
    shiny::updateTextInput(session, "qryTxt", value="")
    shiny::updateRadioButtons(session, "mode", choices=input$mode, selected="VIEW")
    updateQueryString("?", "push", session)
    session$reload()
  })

  updateFromUrlParams <- function(qStr) {
    if ("geneA" %in% names(qStr)) { shiny::updateTextInput(session, "qryA", value=qStr[["geneA"]]) }
    if ("geneB" %in% names(qStr)) { shiny::updateTextInput(session, "qryB", value=qStr[["geneB"]]) }
    if ("qryTxt" %in% names(qStr)) { shiny::updateTextInput(session, "qryTxt", value=qStr[["qryTxt"]]) }
    if ("mode" %in% names(qStr)) { shiny::updateRadioButtons(session, "mode", choices=input$mode, selected=qStr[["mode"]]) }
  }

  qryVals <- reactive({
    input$goSubmit #trigger with goSubmit button?
    vals <- list(geneA = NA, geneB = NA, qryTxt = NA, mode = NA)
    qStr <- httpQstr()
    if (i_query==0 & length(names(qStr))>0) {  #1st query may be via URL http param.
      vals$geneA <- ifelse("geneA" %in% names(qStr), qStr[["geneA"]], NA)
      vals$geneB <- ifelse("geneB" %in% names(qStr), qStr[["geneB"]], NA)
      vals$qryTxt <- ifelse("qryTxt" %in% names(qStr), qStr[["qryTxt"]], NA)
      vals$mode <- ifelse("mode" %in% names(qStr), qStr[["mode"]], NA)
      updateFromUrlParams(qStr)
    } else {
      vals$geneA <- ifelse("geneA" %in% names(input), input$geneA, NA)
      vals$geneB <- ifelse("geneB" %in% names(input), input$geneB, NA)
      vals$qryTxt <- ifelse("qryTxt" %in% names(input), input$qryTxt, NA)
      vals$mode <- ifelse("mode" %in% names(input), input$mode, NA)
    }
    message(sprintf("DEBUG: qryVals(): i_query: %d; input$geneA: %s; vals$geneA: %s; input$geneB: %s; vals$geneB: %s; vals$qryTxt: %s", i_query, input$geneA, vals$geneA, input$geneB, vals$geneB, input$qryTxt))
    i_query <<- i_query + 1  # Must assign to up-scoped variable.
    return(vals)
  })

#  qryA <- reactive({
#    input$goSubmit # Re-run this and downstream on action button.
#    i_query <<- i_query + 1  # Must assign to up-scoped variable.
#    if (i_query==1 && length(names(httpQstr()))>0 && "geneA" %in% names(httpQstr())) {
#      return(httpQstr()[["geneA"]])
#    }
#    if (inputMode()=="TXTSEARCH") { return(NULL) }
#    if (input$qryA=="") { return(NULL) }
#    return(input$qryA)
#  })
  symbA <- reactive({
    if (is.na(qryVals()$geneA)) { return(NULL) }
    symb <- gene[ENSG==qryVals()$geneA, symbol]
    if (length(symb)>1) {
      message(sprintf("ERROR: multiple geneSymbols for qryA=%s: %s", qryVals()$geneA, paste(collapse=",", symb)))
      return(symb[1])
    } else {
      message(sprintf("DEBUG: qryA=%s; symbA=%s", qryVals()$geneA, paste(collapse=",", symb)))
      return(symb)
    }
  })
  chrA <- reactive({
    if (is.na(qryVals()$geneA)) { return(NA) }
    return(gene[ENSG==qryVals()$geneA, chr])
  })
  
#  qryB <- reactive({
#    if (length(names(httpQstr()))>0 && "geneB" %in% names(httpQstr())) {
#      return(httpQstr()[["geneB"]])
#    }
#    if (input$qryB %in% c("", "NONE", "none")) { return(NULL) }
#    return(input$qryB)
#  })
  symbB <- reactive({
    if (is.na(qryVals()$geneB)) { return(NULL) }
    symb <- gene[ENSG==qryVals()$geneB, symbol]
    if (length(symb)>1) {
      message(sprintf("ERROR: multiple geneSymbols for qryB=%s: %s", qryVals()$geneB, paste(collapse=",", symb)))
      return(symb[1])
    } else {
      return(symb)
    }
  })
  chrB <- reactive({
    if (is.na(qryVals()$geneB)) { return(NA) }
    return(gene[ENSG==qryVals()$geneB, chr])
  })

  # If space-separated list, convert input query to regular expression.
  qryRex <- reactive({
    if (is.na(qryVals()$qryTxt)) { return(NA) }
    if (is.na(qryVals()$qryTxt)) { return(NA) }
    if (gsub(" ", "", qryVals()$qryTxt)=="") { return(NA) }
    qtxt <- sub("^ *(.*[^ ]) *$", "\\1", qryVals()$qryTxt)
    if (nchar(qtxt)<3) { return(NA) }
    if (grepl(" ", qtxt)) {
      vals <- strsplit(qtxt, " +")[[1]]
      qrex <- sprintf("(^%s$)", paste0(vals, collapse="$|^"))
    } else {
      qrex <- qtxt
    }
    return(qrex)
  })

#  inputMode <- reactive({
#    if (length(names(httpQstr()))>0 && "mode" %in% names(httpQstr())) {
#      return(httpQstr()[["mode"]])
#    } else {
#      return(input$mode)
#    }
#  })
  
  hits <- reactive({
    if (qryVals()$mode == "SIMSEARCH" ) {
      if (is.na(qryVals()$geneA)) { return(NULL) }
      if (sum(ggc$ENSGA==qryVals()$geneA | ggc$ENSGB==qryVals()$geneA)==0) { return(NULL) }
      ggc_hits <- ggc[ENSGA==qryVals()$geneA | ENSGB==qryVals()$geneA]
      if (sum(ggc_hits$Group %in% input$groups)==0) { return(NULL) }
      ggc_hits <- ggc_hits[Group %in% input$groups]
      if (input$score=="wRho") {
        ggc_hits[, Score := round(wRho, digits=2)]
      } else if (input$score=="Ruzicka") {
        ggc_hits[, Score := round(Ruzicka, digits=2)]
      } else {
        ggc_hits[, Score := round(Combo, digits=2)]
      }
      ggc_hits[, EnsemblID := as.character(NA)] #Populate with non-query gene.
      ggc_hits[ENSGA==qryVals()$geneA, EnsemblID := ENSGB]
      ggc_hits[ENSGB==qryVals()$geneA, EnsemblID := ENSGA]
      gene_cols <- c("ENSG", "uniprot", "symbol", "name", "chr", "idgTDL", "idgFamily")
      ggc_hits <- merge(ggc_hits, gene[, ..gene_cols], by.x="EnsemblID", by.y="ENSG", all.x=T, all.y=F)
      hits_cols <- c("EnsemblID", "uniprot", "symbol", "name", "chr", "idgTDL", "idgFamily", "Group", "Score") #datatable() ref by # (0+)
      ggc_hits <- ggc_hits[, ..hits_cols]
      if ("Dissim" %in% input$opts) {
        setorder(ggc_hits, Score)
      } else {
        setorder(ggc_hits, -Score)
      }
      return(ggc_hits)
    } else if (qryVals()$mode == "TXTSEARCH") {
      message(sprintf("DEBUG: is.na(qryRex()): %s", as.character(is.na(qryRex()))))
      if (is.na(qryRex())) { return(NULL) }
      if (input$field == "Symbol") {
        gene_hits <- gene[grepl(qryRex(), symbol, ignore.case=input$iCase)]
      } else if (input$field == "Name") {
        gene_hits <- gene[grepl(qryRex(), name, ignore.case=input$iCase)]
      }
      message(sprintf("DEBUG: nrow(gene_hits)=%d", nrow(gene_hits)))
      if (nrow(gene_hits)==0) { return(NULL) }
      setnames(gene_hits, old="ENSG", new="EnsemblID")
      hits_cols <- c("EnsemblID", "uniprot", "symbol", "name", "chr", "idgTDL", "idgFamily") #datatable() ref by # (0+)
      gene_hits <- gene_hits[, ..hits_cols]
      gene_hits <- gene_hits[OrderGeneSymbols(symbol)]
      return(gene_hits)
    } else { return(NULL) }
  })
  
  output$hits_exist <- renderText({
    message(sprintf("DEBUG: hits_exist: %s", as.character(!is.null(hits()))))
    if (!grepl("SEARCH", qryVals()$mode)) { return("FALSE") }
    return(as.character(!is.null(hits())))
  })

  hit <- reactive({
    if (is.null(hits())) { return(NULL) }
    if (qryVals()$mode == "SIMSEARCH" ) {
      if (is.na(qryVals()$geneA)) { return(NULL) }
      hit_best <- hits()$EnsemblID[1]
      if (!is.na(hit_best)) {
        sim <- hits()$Score[1]
        message(sprintf("NOTE: best hit [sim=%.3f]: %s:%s (%s)", sim, hit_best, gene$symbol[gene$ENSG==hit_best], gene$name[gene$ENSG==hit_best]))
      } else {
        message(sprintf("ERROR: search failed."))
      }
      return(hit_best)
    } else if (qryVals()$mode == "TXTSEARCH") {
      hit_best <- hits()$EnsemblID[1]
      return(hit_best)
    } else { return(NULL) }
  })
  hit_symbol <- reactive({
    if (is.null(hit())) { return("") }
    gene[ENSG==hit(), symbol]
  })
  hit_chr <- reactive({
    if (is.null(hit())) { return(NULL) }
    gene[ENSG==hit(), chr]
  })

  output$result_htm <- reactive({
    htm <- sprintf("<B>Results (%s):</B>", qryVals()$mode)
    if (qryVals()$mode=="VIEW" && is.na(qryVals()$geneA)) {
      paste0(htm, "No query. Enter geneA.")
    }
    message(sprintf("DEBUG: (Results) geneA:%s; geneB:%s; mode: %s", qryVals()$geneA, qryVals()$geneB, qryVals()$mode))
    if (!is.na(qryVals()$geneA)) {
      htm <- paste0(htm, sprintf(" GeneA: %s \"%s\"%s", symbA(), gene[ENSG==qryVals()$geneA, name],
	ifelse(("IDG" %in% input$opts), sprintf(" <A HREF=\"https://pharos.nih.gov/idg/targets/%s\" target=\"_blank\">%s</A>", gene[ENSG==qryVals()$geneA, uniprot], icon("external-link",lib="font-awesome")), "")))
      if (!is.na(chrA()) && grepl("^[XY]", chrA())) { htm <- paste0(htm, sprintf(", sex-linked, location %s", chrA())) }
    }
    if (!is.na(qryVals()$geneB)) {
      htm <- paste0(htm, sprintf("; geneB: %s \"%s\"%s", symbB(), gene[ENSG==qryVals()$geneB, name],
	ifelse(("IDG" %in% input$opts), sprintf(" <A HREF=\"https://pharos.nih.gov/idg/targets/%s\" target=\"_blank\">%s</A>", gene[ENSG==qryVals()$geneB, uniprot], icon("external-link",lib="font-awesome")), "")))
      if (!is.na(chrB()) && grepl("^[XY]", chrB())) { htm <- paste0(htm, sprintf(", sex-linked, location %s", chrB())) }
    }
    if (!is.na(qryRex())) {
      htm <- paste0(htm, sprintf(" QueryText: \"%s\"", qryVals()$qryTxt))
    }
    if (grepl("SEARCH", qryVals()$mode)) {
      htm <- paste0(htm, sprintf("; found: %d", ifelse(!is.null(hits()), nrow(hits()), 0)))
      #if (!is.null(hit_chr()) & grepl("^[XY]", hit_chr())) { htm <- paste0(htm, sprintf(", sex-linked, location %s", hit_chr())) }
    }
    return(htm)
  })

  output$log_htm <- reactive({
    htm <- db_htm
    htm
  })

  ### Assigns input$datarows_rows_selected
  ### Hide ENSG, Uniprot columns.
  ### Note col #s start with 0.
  output$datarows <- renderDataTable({
    if (is.null(hits())) { return(NULL) }
    if ("IDG" %in% input$opts) {
      invis_cols <- c(0,1)
    } else {
      invis_cols <- c(0,1,5,6)
    }
    if (qryVals()$mode=="SIMSEARCH") {
      colnames=c("EnsemblID", "uniprot", "Symbol", "Name", "Chr", "idgTDL","idgFamily", "Group", input$score)
      center_cols <- c(2,4,5,6,7,8)
    } else if (qryVals()$mode=="TXTSEARCH") {
      colnames=c("EnsemblID", "uniprot", "Symbol", "Name", "Chr", "idgTDL","idgFamily")
      center_cols <- c(2,4,5,6)
    }
    DT::datatable(data=hits(), rownames=F, 
        selection=list(target="row", mode="multiple", selected=c(1)),
	      class="cell-border stripe", style="bootstrap",
	      options=list(dom='tip', #dom=[lftipr]
		autoWidth=T,
		columnDefs = list(
			list(className='dt-center', targets=center_cols),
			list(visible=F, targets=invis_cols)
			)
		), 
	      colnames=colnames) %>%
        formatRound(digits=2, columns=ncol(hits()))
  }, server=T)

  hits_export <- reactive({
    if (is.null(hits())) { return(NULL) }
    hits_out <- hits()
    if (qryVals()$mode=="SIMSEARCH") {
      hits_out["Query"] <- symbA()
      hits_out <- hits_out[, c(ncol(hits_out), 1:(ncol(hits_out)-1))] #Query col 1st.
      setnames(hits_out, c("Query", "EnsemblID", "UniProt", "GeneSymbol", "GeneName", "Chr",  "idgTDL", "idgFam", "Group", input$score))
      return(hits_out)
    } else if (qryVals()$mode=="TXTSEARCH") {
      setnames(hits_out, c("EnsemblID", "UniProt", "GeneSymbol", "GeneName", "Chr", "idgTDL", "idgFam"))
      return(hits_out)
    }
  })

  output$hits_file <- downloadHandler(
    filename = function() { "exfiles_hits.tsv" },
    content = function(file) {
      if (is.null(hits_export())) { return(NULL) }
      write_delim(hits_export(), file, delim="\t") 
  })

  plotTitle <- reactive({
    if (qryVals()$mode=="COMPARE" & !is.na(qryVals()$geneB)) {
      titletxt = sprintf("GTEx Gene-Tissue Profiles: %s vs %s<BR>\"%s\" vs \"%s\"", symbA(), symbB(), gene[ENSG==qryVals()$geneA, name], gene[ENSG==qryVals()$geneB,name])
    } else if (qryVals()$mode=="SIMSEARCH" & !is.null(hit())) {
      titletxt = sprintf("Ex-files, GTEx-Profiles: %s <BR>\"%s\"", symbA(), gene[ENSG==qryVals()$geneA, name])
    } else if (qryVals()$mode=="TXTSEARCH" & !is.null(hits())) {
      titletxt = sprintf("Ex-files, GTEx-Profiles: \"%s\"", qryVals()$qryTxt)
    } else { #VIEW
      titletxt = sprintf("Ex-files, GTEx-Profiles: %s<BR>\"%s\"", symbA(), gene[ENSG==qryVals()$geneA, name])
    }
    return(titletxt)
  })
    
  output$plot <- renderPlotly({
    if (is.na(qryVals()$geneA) & is.null(hits())) { return(NULL) }
    if (length(input$groups)==0) { return(NULL) }

    if (!is.na(qryVals()$geneA)) {
      smtsds <- tissue$SMTSD
      qryA_profile_f <- as.numeric(eps[ENSG==qryVals()$geneA & SEX=="F"][1, ..smtsds])
      qryA_profile_m <- as.numeric(eps[ENSG==qryVals()$geneA & SEX=="M"][1, ..smtsds])
      rhoAfm <- wPearson(qryA_profile_f, qryA_profile_m)
      ruzAfm <- Ruzicka(qryA_profile_f, qryA_profile_m)
      qryA_profile_n <- (qryA_profile_f+qryA_profile_m)/2 #Non-sexed (F+M)/2
    }

    if (qryVals()$mode=="COMPARE" & !is.na(qryVals()$geneB)) {
      smtsds <- tissue$SMTSD
      qryB_profile_f <- as.numeric(eps[ENSG==qryVals()$geneB & SEX=="F"][1, ..smtsds])
      qryB_profile_m <- as.numeric(eps[ENSG==qryVals()$geneB & SEX=="M"][1, ..smtsds])
      qryB_profile_n <- (qryB_profile_f+qryB_profile_m)/2
      #
      rhoNab <- wPearson(qryA_profile_n, qryB_profile_n)
      rhoBfm <- wPearson(qryB_profile_f, qryB_profile_m)
      rhoFab <- wPearson(qryA_profile_f, qryB_profile_f)
      rhoMab <- wPearson(qryA_profile_m, qryB_profile_m)
      #
      ruzNab <- Ruzicka(qryA_profile_n, qryB_profile_n)
      ruzBfm <- Ruzicka(qryB_profile_f, qryB_profile_m)
      ruzFab <- Ruzicka(qryA_profile_f, qryB_profile_f)
      ruzMab <- Ruzicka(qryA_profile_m, qryB_profile_m)
      #
    }

    ### PLOT:

    xaxis = list(tickangle=45, tickfont=list(family="Arial", size=10), categoryorder = "array", categoryarray = tissue$SMTSD)
    yaxis = list(title=ifelse("LogY" %in% input$opts, "Expression: LOG<SUB>10</SUB>(1+TPM)", "Expression: TPM"))
    
    p <- plot_ly() %>%
      layout(xaxis = xaxis, yaxis = yaxis, 
         title = plotTitle(),
         margin = list(t=100, r=80, b=160, l=60),
         legend = list(x=.9, y=1),
         showlegend=T,
         font = list(family="Arial", size=14)
      )

    annos <- c()

    if (!is.na(qryVals()$geneA)) {
      if ("F" %in% input$groups) {
        p <-  add_trace(p, name = paste("(F)", symbA()), x = tissue$SMTSD, y = EpLogIf(qryA_profile_f, ("LogY" %in% input$opts)),
          type = 'scatter', mode = 'lines+markers',
          marker = list(symbol="circle", size=10),
          text = paste0(symbA(), ": ", tissue$SMTSD))
    }
      if ("M" %in% input$groups) {
        p <- add_trace(p, name = paste("(M)", symbA()), x = tissue$SMTSD, y = EpLogIf(qryA_profile_m, ("LogY" %in% input$opts)),
          type = 'scatter', mode = 'lines+markers',
          marker = list(symbol="circle", size=10),
          text = paste0(symbA(), ": ", tissue$SMTSD))
    }
      if ("C" %in% input$groups) {
        p <- add_trace(p, name = paste("(C)", symbA()), x = tissue$SMTSD, y = EpLogIf(qryA_profile_n, ("LogY" %in% input$opts)),
          type = 'scatter', mode = 'lines+markers',
          marker = list(symbol="circle", size=10),
          text = paste0(symbA(), ": ", tissue$SMTSD))
      }
    }
    if (qryVals()$mode=="COMPARE" & !is.na(qryVals()$geneB)) {
      if ("F" %in% input$groups) {
        p <- add_trace(p, name = paste("(F)", symbB()), x = tissue$SMTSD, y = EpLogIf(qryB_profile_f, ("LogY" %in% input$opts)),
          type = 'scatter', mode = 'lines+markers',
          marker = list(symbol="circle", size=10),
          text = paste0(symbB(), ": ", tissue$SMTSD))
        annos <- c(annos, sprintf("Fab: rho = %.2f; ruz = %.2f", rhoFab, ruzFab))
      }
      if ("M" %in% input$groups) {
        p <- add_trace(p, name = paste("(M)", symbB()), x = tissue$SMTSD, y = EpLogIf(qryB_profile_m, ("LogY" %in% input$opts)),
          type = 'scatter', mode = 'lines+markers',
          marker = list(symbol="circle", size=10),
          text = paste0(symbB(), ": ", tissue$SMTSD))
        annos <- c(annos, sprintf("Mab: rho = %.2f; ruz = %.2f", rhoMab, ruzMab))
      }
      if ("C" %in% input$groups) {
        p <- add_trace(p, name = paste("(C)", symbB()), x = tissue$SMTSD, y = EpLogIf(qryB_profile_n, ("LogY" %in% input$opts)),
          type = 'scatter', mode = 'lines+markers',
          marker = list(symbol="circle", size=10),
          text = paste0(symbB(), ": ", tissue$SMTSD))
        annos <- c(annos, sprintf("Nab: rho = %.2f; ruz = %.2f", rhoNab, ruzNab))
      }
    } else if (qryVals()$mode %in% c("SIMSEARCH", "TXTSEARCH") & !is.null(hit())) {
      ##
      # Include genes selected via interactive table.
      # Each row has hits()$Group[i] F|M|N so how to handle that?
      ##
      rows_selected <- input$datarows_rows_selected
      smtsds <- tissue$SMTSD
      if (!is.null(rows_selected)) {
        for (i in rows_selected) {
          hit_profile_f <- as.numeric(eps[ENSG==hits()$EnsemblID[i] & SEX=="F"][1, ..smtsds])
          hit_profile_m <- as.numeric(eps[ENSG==hits()$EnsemblID[i] & SEX=="M"][1, ..smtsds])
          hit_profile_n <- (hit_profile_f+hit_profile_m)/2
          #
          if ("F" %in% input$groups) {
            p <- add_trace(p, name = paste("(F)", hits()$symbol[i]), x = tissue$SMTSD, y = EpLogIf(hit_profile_f, ("LogY" %in% input$opts)),
                type = 'scatter', mode = 'lines+markers',
                marker = list(symbol="circle", size=10),
                text = paste0(hits()$symbol[i], ": ", tissue$SMTSD))
            if (!is.na(qryVals()$geneA)) { annos <- c(annos, sprintf("Fab: rho = %.2f; ruz = %.2f", wPearson(qryA_profile_f, hit_profile_f), Ruzicka(qryA_profile_f, hit_profile_f))) }
          }
          if ("M" %in% input$groups) {
            p <- add_trace(p, name = paste("(M)", hits()$symbol[i]), x = tissue$SMTSD, y = EpLogIf(hit_profile_m, ("LogY" %in% input$opts)),
                type = 'scatter', mode = 'lines+markers',
                marker = list(symbol="circle", size=10),
                text = paste0(hits()$symbol[i], ": ", tissue$SMTSD))
            if (!is.na(qryVals()$geneA)) { annos <- c(annos, sprintf("Mab: rho = %.2f; ruz = %.2f", wPearson(qryA_profile_m, hit_profile_m), Ruzicka(qryA_profile_m, hit_profile_m))) }
          }
          if ("C" %in% input$groups) {
            hit_profile_n <- (hit_profile_f + hit_profile_m)/2
            p <- add_trace(p, name = paste("(C)", hits()$symbol[i]), x = tissue$SMTSD, y = EpLogIf(hit_profile_n, ("LogY" %in% input$opts)),
                type = 'scatter', mode = 'lines+markers',
                marker = list(symbol="circle", size=10),
                text = paste0(hits()$symbol[i], ": ", tissue$SMTSD))
            if (!is.na(qryVals()$geneA)) { annos <- c(annos, sprintf("Nab: rho = %.2f; ruz = %.2f", wPearson(qryA_profile_n, hit_profile_n), Ruzicka(qryA_profile_n, hit_profile_n))) }
          }
        }
      }
    } else { #VIEW
      annos <- c(sprintf("Afm: rho = %.2f; ruz = %.2f", rhoAfm, ruzAfm))
    }
    #
    if ("Annplot" %in% input$opts) {
      p <- add_annotations(p, text=paste0(collapse="<br>", annos), showarrow=F, x=.1, y=1, xref="paper", yref="paper")
    }
    p$elementId <- NULL #Hack to suppress spurious warnings.
    return(p)
  })
}
###
shinyApp(ui, server)
#
